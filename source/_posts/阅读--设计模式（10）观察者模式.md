---
title: 阅读--设计模式（10）观察者模式
date: 2023-04-30 16:03:50
tags:
  - 阅读
  - 面试题
  - 设计模式
  - 观察者模式
categories:
  - [阅读]
---

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns

观察者模式有一个“别名”，叫`发布-订阅模式`，但两者存在着细微的差异。

### 实践
在观察者模式里，至少有两个关键角色，发布者和订阅者。用面向对象的方式表达，就是得有两个类。
基本的发布者应该具有三个功能，增加订阅者，通知订阅者，移除订阅者的能力。

```js
// 定义发布者
class Publisher {
  constructor() {
    this.observers = []
    console.log('Publisher created')
  }
  add(observer) {
    console.log('Publisher.add invoked')
    this.observers.push(observer)
  }
  remove(observer) {
    console.log('Publisher.remove invoked')
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1)
      }
    })
  }
  // 通知
  notify() {
    console.log('Publisher.notify invoked')
    this.observers.forEach(observer => {
      observer.update(this)
    })
  }
}
```

其次就是订阅者，订阅者的能力很简单，它的行为只有两个：被通知，去执行。
```js
class Observer {
  constructor() {
    console.log('Observer created')
  }

  update() {
    console.log('Observer.update invoked')
  }
}
```

所有定制化的发布者订阅者都可以基于这两个类进行改写，如果要拓展发布者类，来监听某个特定状态的变化：
```js
class PrdPublisher extends Publisher {
  constructor() {
    super()
    // 初始化
    this.prdState = null
    this.observers = []
    console.log('PrdPublisher is created')
  }

  getState() {
    console.log('PrdPublisher.getState invoked')
    return this.prdState
  }

  setState() {
    console.log('PrdPublisher.setState invoked')
    // prd的值发生改变
    this.prdState = state
    // 需求文档变更，立刻通知所有开发者
    this.notify()
  }
}

```

作为订阅方，任务也变得具体起来：
```js
class DeveloperObserver extends Observer {
  constructor() {
      super()
      // 需求文档一开始还不存在，prd初始为空对象
      this.prdState = {}
      console.log('DeveloperObserver created')
  }
  
  // 重写一个具体的update方法
  update(publisher) {
      console.log('DeveloperObserver.update invoked')
      this.prdState = publisher.getState()
      // 调用工作函数
      this.work()
  }
  
  // work方法，一个专门搬砖的方法
  work() {
      // 获取需求文档
      const prd = this.prdState
      // 开始基于需求文档提供的信息搬砖。。。
      console.log('996 begins...')
  }
}
```


下面，可以 new 一个 PrdPublisher 对象（产品经理），她可以通过调用 setState 方法来更新需求文档。需求文档每次更新，都会紧接着调用 notify 方法来通知所有开发者，这就实现了定义里所谓的：

目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。
```js
// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver()
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver()
// 创建订阅者：测试同学小B
const B = new DeveloperObserver()
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher()
// 需求文档出现了
const prd = {
    // 具体的需求内容
    ...
}
// 韩梅梅开始拉群
hanMeiMei.add(liLei)
hanMeiMei.add(A)
hanMeiMei.add(B)
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd)
```
