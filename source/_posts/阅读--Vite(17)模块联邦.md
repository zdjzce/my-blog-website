---
title: 阅读--Vite(17) 模块联邦
date: 2023-09-22 20:23:00
tags:
  - 阅读
  - Vite
categories:
  - [阅读]
---

2020 年，Webpack 提出了 `Module Federation（模块联邦）`，这个特性很好地解决了 `多应用模块复用` 的问题，不仅在 Webpack，在 Vite 中同样可以实现这个特性。


### 模块共享常见解决方案的优缺点
在大型项目中，往往会有很多细分的应用，而每个应用又彼此独立，公司内部常常会有很多通用的模块，比如公共组件、工具函数、第三方依赖等。对于这些代码，常见的解决方案有以下几种：

#### 1. 发布 NPM 包
发布 npm 包是常见的复用模块的做法，将模块单独发一个包，在其他的项目中进行引用，不过问题很显而易见: `当一个包发布时，引用了这个包的所有项目都得重新安装，并且调试`。这就导致**流程变得复杂**，引入公共库后，**导致最后构建的产物体积偏大，构建速度较慢**。

#### 2. Git Submodule
通过 `git submodule` 的方式，可以将代码封装成公共 Git 仓库，复用到不同仓库中，但也需要经历：
1. 公共库改动，提交到远端仓库。
2. 所有的应用通过 Git Submodule 命令更新子仓库代码，重新构建。

可以看到，与第一种方式其实并没有本质上的区别。

#### 3. 依赖外部化(external) + CDN 引入
通过前面两种方式可以发现，最麻烦的步骤其实是：`一旦发布，引用其的项目就都要重新构建`。那么 CDN 就可以解决这个问题，在内部利用构建工具将公共依赖 external 掉，然后在 html 中引入相应的 script 标签，最后会自己挂载在 window 上。这样可以实现模块在所有应用间进行共享。不过它也存在众多缺点：
1. 兼容性，并不是所有依赖都有 UMD 格式产物，这种方案不能覆盖所有第三方 npm 包。
2. 依赖顺序，比如 antd ，他依赖了 react 和 moment 库，那么这两者就需要 external，如果 moment 放在了 antd 的后面，代码就可能无法运行。一旦第三方包数量庞大就需要逐个处理依赖，很麻烦。
3. 产物体积，由于依赖被 external，应用在引用其 CDN 时，会全量引用其代码，这种情况下就没办法通过 Tree Shaking 来去除无用代码了，会导致应用的性能有所下降。


#### 4. Monorepo
Monorepo 可以很好地解决模块复用的问题，在 Monorepo 架构下，多个项目可以放在同一个 Git 仓库中，各个互相依赖的子项目通过软链的方式进行引用。代码复用非常方便。
不过它也存在问题：
1. **所有应用代码都必须放在一个仓库**，如果是旧项目，并且每个项目都是一个 Git 仓库，那么使用 Monorepo 之后项目架构调整会很大，改造成本高。
2. 当项目数量多起来之后，整体构建时间会变长，安装依赖会变慢。项目构建是个大问题，跟发 npm 包方案一样，所有的公共代码都需要进入项目的构建流程中，产物体积还是会偏大。


#### 5. MF 模块联邦