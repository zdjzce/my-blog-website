---
title: 阅读--Node.js(2) 事件循环与异步I/O
date: 2023-08-29 11:36:12
tags:
  - 阅读
  - Node.js
categories:
  - [阅读]
---

> JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码，收集和处理事件以及执行队列中的子任务，这个模型与其他语言中的模型截然不同。
> 引用自 MDN
这段话讲的是 JavaScript，不是 Node.js。在浏览器中这是针对前端在 DOM 中进行操作的，V8 自己有实现一套事件循环。而 **Node.js 也实现了自己的一套事件循环**。

***

Node.js 作为后端服务运行时，必须得有处理系统事件的能力。去处理各种文件的读写事件，一个最简单的事件循环伪代码：

```js
while (还有事件在监听) {
  const events = 从监听中获取所有事件信息;
  for (const event of events) {
    处理(event);
  }
}
```

一个 `setTimeout` 可以是一个 Timer 事件，一个文件读写是一个系统的** I/O 事件**。其他各大系统平台已经有很成熟的方案。这些方案统称为 I/O 多路复用。

> Node.js 基于 Ryan Dahl 自己开发的 libuv ，完成了自己的事件循环与异步 I/O。


### libuv 的诞生
libuv 是一个聚焦异步 I/O 的跨平台库，他就是为 Node.js 而生的，它抹平了各平台的差异。API 也很简单，包含了文件描述符的监听、读写、连接以及定时器。并且对于各种网络请求也有支持，比如 DNS 查询。


### 事件循环 != 异步 I/O
**事件循环是一种并发模型，本质是一个死循环，在循环中不断处理到来的事件**。而 **异步 I/O 事件只是事件循环中事件的一种。**在死循环中，大部分时间都在阻塞等待事件，不消耗CPU。而是等待底层 **epoll** 得到事件。一旦有事件完成了，epoll 就会得到通知，从而进入死循环的下一步。比如文件读取完成，那么 libuv 的事件循环会把对应信息给到等待这个事件的回调。也就是说事件触发之后事件循环才能去做其他逻辑。

如果转换为用户的 Node.js 代码，大概长这样：

```js
fs.readFile(filename, (err, content) => {
  fs.writeFile(filename, content, err => {
    // 假设这里写文件需要两秒钟
  })

  setTimeout(() => {
    console.log('time done')
  }, 1000)

})

```

依次解释就是：
1. 读取文件 (readFile)
2. 事件循环阻塞直到收到事件，触发回调：
   - 写文件
   - 设置定时器
3. 收到定时器事件，触发回调回调内 log.
4. 收到写事件，触发回调，即注释的回调。
   

> 注: epoll 是 Linux 操作系统中的一种 I/O 多路复用技术。在 Node.js 中，事件循环是处理异步操作的核心机制，而 I/O 多路复用技术则是事件循环的关键部分之一。epoll 用于高效地处理大量并发连接，以便在多个文件描述符中检测 I/O 事件（如读、写、异常等）。

> 在 Node.js 中，事件循环使用了 libuv 库，而 libuv 库在 Linux 系统中使用了 epoll。epoll 的主要作用是将 I/O 操作与其他执行任务分离，从而实现高性能的并发处理。

> 简单来说，epoll 是 Linux 系统中的一种 I/O 多路复用技术，用于提高 Node.js 事件循环的效率。通过使用 epoll，Node.js 可以同时处理大量 I/O 事件，从而提高应用程序的性能。，与在 O(n) 时间内运行的旧系统调用不同，epoll 在 O(1) 时间内运行。它使用红黑树数据结构来跟踪当前正在监视的所有文件描述符。


在 Node.js 中，uv_async_t 是 libuv 库提供的一种异步处理机制。uv_async_t 主要用于在多线程环境中实现线程间的通信。它允许在一个线程中发送信号，以便在另一个线程（通常是主线程）中运行回调函数。这种机制在 Node.js 中的主要作用是实现线程池与主事件循环之间的通信。

可以看到 Node.js 使用的 libuv 内部的 epoll 以及 uv_async_t 无不表示着 Node.js 底层是多线程的，只不过常听见的 Node.js 是单线程这个理论是对用户而言，而真正底层可不是，其他线程对用户是不开放的。