---
title: 阅读--设计模式（7）代理模式
date: 2023-04-28 12:12:20
tags:
  - 阅读
  - 面试题
  - 设计模式
  - 代理模式
categories:
  - [阅读]
---
### ES6 Proxy

```js
const proxy = new Proxy(obj, handler)
```
代码中的第一个参数是目标对象，第二个参数也是一个对象，用来定义**代理的行为**，当通过 proxy 去访问目标对象的时候，handler 会对行为作一层拦截，每次访问都要经过 handler 这个第三方。

### “婚介所”的实现
假设现在要开设一个网上的婚介所，有会员制，不是会员或者没实名不能直接访问到其他用户的真实信息。
```js
const girl = {
  // 姓名
  name: '小美',
  // 自我介绍
  aboutMe: '...'
  // 年龄
  age: 24,``
  // 职业
  career: 'teacher',
  // 假头像
  fakeAvatar: 'xxxx'
  // 真实头像
  avatar: 'xxxx',
  // 手机号
  phone: 123456,
}

const baseInfo = ['age', 'career']
const privateInfo = ['avatar', 'phone']

// 当前访问的用户
const user = {
  isValidated: true,
  isVIP: false
}

// 在用户查看信息时进行拦截
const Lovers = new Proxy(girl, {
  get: function(girl, key) {
    if (baseInfo.indexOf(key) != -1 && !user.isValidated) {
      alert('您还没有完成验证哦')
      return
    }

    if (user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
      alert('只有VIP才可以查看该信息')
      return
    }
  }

})

```

### 代理模式的实践
事件代理、虚拟代理、缓存代理、保护代理。代理模式可以玩出花来，但变得再多，玩的再花，核心操作都是死的。

#### 1. 事件代理
事件代理属于高频面试题，它的场景是一个父元素下有多个子元素。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件代理</title>
</head>
<body>
  <div id="father">
    <a href="#">链接1号</a>
    <a href="#">链接2号</a>
    <a href="#">链接3号</a>
    <a href="#">链接4号</a>
    <a href="#">链接5号</a>
    <a href="#">链接6号</a>
  </div>
</body>
</html>
```

现在的需求是，希望鼠标点击每个 a 标签，都可以弹出“我是xxx”这样的提示。比如点击第一个 a 标签。弹出我是链接一号这样的提示。按照最简单最粗暴的思路就是给六个监听函数给子元素。如果 a 标签进一步增多，那么性能开销会更大。

假如不用代理模式，而是循环监听
```js
 const aNodes = document.getELementById('father').getElementsByTagName('a')

 const aLen = aNodes.length

 for (let i = 0; i < aLen; i++) {
  aNodes[i].addEventListener('click', e => {
    e.preventDefault()
    alert(`我是${aNodes[i].innerText}`)
  })
 }
```
考虑到有冒泡特性，当点击 a 元素，会冒泡到父元素 div 上，从而被监听到，如此一来，点击事件的监听函数只需要在 div 上绑定一次就行。这就是事件代理。

```js
// 获取父元素
const father = document.getElementById('father')

// 给父元素安装一次监听函数
father.addEventListener('click', e => {
  if (e.target.tagName === 'A') {
    e.preventDefault()
    alert(`我是${e.target.innerText}`)
  }
})
```
